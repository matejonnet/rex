package org.jboss.pnc.scheduler.model;

import lombok.*;
import org.infinispan.protostream.annotations.ProtoDoc;
import org.infinispan.protostream.annotations.ProtoFactory;
import org.infinispan.protostream.annotations.ProtoField;
import org.jboss.msc.service.ServiceName;
import org.jboss.pnc.scheduler.common.enums.Mode;
import org.jboss.pnc.scheduler.common.enums.State;
import org.jboss.pnc.scheduler.common.enums.StopFlag;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Task is an entity that holds data of remotely executed process.
 *
 * TaskController manipulates Task's data.
 *
 * Service has to be installed through BatchTaskInstaller that is provided by TaskTarget. After installation, Task's
 * data is held by Infinispan cache inside TaskRegistry/TaskContainer.
 *
 * @author Jan Michalov <jmichalo@redhat.com>
 */
@Setter
@ToString
@AllArgsConstructor
@Builder(toBuilder = true)
@ProtoDoc("@Indexed")
public class Task {
    /**
     * Uniquely identifies a Task and serves as a key in Infinispan cache.
     */
    @Getter
    private final ServiceName name;

    /**
     * Holds data for communication with remote entity.
     *
     * f.e. to start/stop remote execution
     */
    private RemoteAPI remoteEndpoints;

    /**
     * TaskController mode.
     */
    private Mode controllerMode;

    /**
     * Current state of a task. Default is State.IDLE.
     */
    private State state;

    /**
     * Tasks that are dependent on this task.
     *
     * Parents of this Service.
     */
    @Singular
    @Getter
    private Set<ServiceName> dependants = new HashSet<>();

    /**
     * Number of unfinishedDependencies. Task can't remotely start if the number is positive.
     */
    private int unfinishedDependencies;

    @Singular
    @Getter
    private Set<ServiceName> dependencies = new HashSet<>();

    /**
     * Payload sent to remote entity.
     */
    private String payload;

    private StopFlag stopFlag;

    @Singular
    private List<ServerResponse> serverResponses = new ArrayList<>();

    /**
     * Used by infinispan to create .proto schema and marshaller values in the cache
     *
     * Use constructor generated by Lombok instead
     */
    @Deprecated
    @ProtoFactory
    public Task(String stringName, RemoteAPI remoteEndpoints, Mode controllerMode, State state, Set<String> stringDependants, int unfinishedDependencies, Set<String> stringDependencies, String payload, StopFlag stopFlag, List<ServerResponse> serverResponses) {
        this.name = ServiceName.parse(stringName);
        this.remoteEndpoints = remoteEndpoints;
        this.controllerMode = controllerMode;
        this.state = state;
        this.dependants = stringDependants.stream().map(ServiceName::parse).collect(Collectors.toSet());
        this.unfinishedDependencies = unfinishedDependencies;
        this.dependencies = stringDependencies.stream().map(ServiceName::parse).collect(Collectors.toSet());
        this.payload = payload;
        this.stopFlag = stopFlag;
        this.serverResponses = serverResponses;
    }

    public void incUnfinishedDependencies() {
        unfinishedDependencies++;
    }

    public void decUnfinishedDependencies() {
        unfinishedDependencies--;
    }

    @ProtoField(number = 1)
    @ProtoDoc("@Field(store=Store.YES)")
    public String getStringName() {
        return name.getCanonicalName();
    }

    @ProtoField(number = 2)
    public RemoteAPI getRemoteEndpoints() {
        return remoteEndpoints;
    }
    @ProtoField(number = 3)
    public Mode getControllerMode() {
        return controllerMode;
    }

    @ProtoField(number = 4)
    @ProtoDoc("@Field(store=Store.YES)")
    public State getState() {
        return state;
    }

    @ProtoField(number = 5)
    public Set<String> getStringDependants() {
        return dependants.stream().map(ServiceName::getCanonicalName).collect(Collectors.toSet());
    }

    @ProtoField(number = 6, defaultValue = "-1")
    public int getUnfinishedDependencies() {
        return unfinishedDependencies;
    }

    @ProtoField(number = 7)
    public Set<String> getStringDependencies() {
        return dependencies.stream().map(ServiceName::getCanonicalName).collect(Collectors.toSet());
    }

    @ProtoField(number = 8)
    public String getPayload() {
        return payload;
    }

    @ProtoField(number = 9)
    public StopFlag getStopFlag() {
        return stopFlag;
    }

    @ProtoField(number = 10)
    public List<ServerResponse> getServerResponses() {
        return serverResponses;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Task task = (Task) o;
        return  name.equals(task.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}
